#!/usr/bin/php
<?php
define('GIT_DEPLOY_DIR', __DIR__ . '/.gitdeploy');
define('VENDOR_DIR', __DIR__ . '/vendor');
ini_set('max_execution_time', 0);

require_once VENDOR_DIR . '/autoload.php';

use phpseclib3\Net\SFTP;

$opts = getopt("lr:", ["revert", 'env:']);
$list = isset($opts['l']);
$revision = isset($opts['r']) ? $opts['r'] : 'HEAD';
$revert = isset($opts['revert']);
$deploy = isset($opts['env']) ? $opts['env'] : 'deploy.ini';
$deploy = GIT_DEPLOY_DIR . '/' . $deploy;
if (substr($deploy, -4) !== '.ini') {
	$deploy .= '.ini';
}

/**
 * Get local path to file containing revision deployed to server.
 * @global string $deploy
 * @return string
 */
function getRemoteRevisionLocalFilepath(): string
{
	global $deploy;
	return GIT_DEPLOY_DIR . '/REMOTE_REVISION-' . basename($deploy, '.ini');
}


/**
 * Add all filepaths from $relPath to $arr
 * @param string $relPath
 * @param array $arr Array to put file list to
 */
function addFilesFromDirectory(string $relPath, array &$arr): void
{
	$absPath = __DIR__ . '/' . $relPath;
	foreach (get_recursive_file_list($absPath, $relPath) as $f) {
		$arr[$f] = $f;
	}
}


function get_recursive_file_list(string $folder, string $prefix = ''): array
{

	# Add trailing slash
	$folder = (substr($folder, strlen($folder) - 1, 1) == '/') ? $folder : $folder . '/';

	$return = [];

	foreach (clean_scandir($folder) as $file) {
		if (is_dir($folder . $file)) {
			$return = array_merge($return, get_recursive_file_list($folder . $file, $prefix . $file . '/'));
		} else {
			$return[] = $prefix . $file;
		}
	}

	return $return;
}


function clean_scandir(string $folder, array $ignore = []): array
{
	$ignore[] = '.';
	$ignore[] = '..';
	$ignore[] = '.DS_Store';
	$return = [];

	foreach (scandir($folder) as $file) {
		if (!in_array($file, $ignore)) {
			$return[] = $file;
		}
	}

	return $return;
}


try {
	$git = new Terra_Git();
	if (!$list) {
		$git->setDeployFile($deploy);
		if ($revert) {
			$git->revert();
		} else {
			$git->deploy($revision);
		}
	} else {
		$remoteRevisionLocalFilePath = getRemoteRevisionLocalFilepath();
		if (file_exists($remoteRevisionLocalFilePath)) {
			$remoteRevision = trim(file_get_contents($remoteRevisionLocalFilePath));
		} else {
			$remoteRevision = NULL;
		}
		$git->setDeployFile($deploy);
		$servers = $git->getServers();
		$serverOptions = reset($servers);
		$files = $git->getFilesToUpload($remoteRevision, $revision, $serverOptions);
		$git->output("Update from $remoteRevision to $revision");
		if (count($files['upload']) === 0 && count($files['delete']) === 0) {
			$git->output('No files to upload or delete.');
		} else {
			if (count($files['upload']) > 0) {
				$git->output("Files to upload:");
				foreach ($files['upload'] as $fileToUpload) {
					$git->output($fileToUpload);
				}
			}

			if (count($files['delete']) > 0) {
				$git->output("Files to delete:");
				foreach ($files['delete'] as $fileToDelete) {
					$git->output($fileToDelete);
				}
			}
		}
	}
} catch (Exception $e) {
	echo $e->getMessage();
}

class Terra_Git
{
	protected array $filesToIgnore = [
		'git-deploy',
		'.gitignore',
	];
	protected bool $print = true;
	protected string $logBuffer = '';
	protected string $logFile = 'git-deploy.log.txt';
	protected array $submodules = [];
	protected array $servers = [];
	protected array $pathsThatExist = [];
	protected string $currentPath = '';


	function __construct()
	{
		# Check if there are any submodules in the git repository.

		$command = "git submodule status";

		$output = [];
		exec($command, $output);

		foreach ($output as $line) {
			$line = preg_split('/\s+/', trim($line));
			if (isset($line[1])) {
				$this->submodules[] = $line[1];
			}
		}
	}


	function setDeployFile(string $deploy): void
	{
		if (!@file_exists($deploy)) {
			throw new Exception("File '$deploy' does not exist.");
		} else {
			$servers = parse_ini_file($deploy, true);
			if (!$servers) {
				throw new Exception("File '$deploy' is not a valid .ini file.");
			} else {
				$this->addServers($servers, basename($deploy, '.ini'));
			}
		}
		$this->ignoreFile($deploy);
	}


	function getServers(): array
	{
		return $this->servers;
	}


	function addServers(array $servers, string $env): void
	{
		foreach ($servers as $uri => $options) {

			if (substr($uri, 0, 6) === 'ftp://' || substr($uri, 0, 7) === 'ftps://' || substr($uri, 0, 7) === 'sftp://') {
				$options = array_merge($options, parse_url($uri));
			}

			# Throw in some default values, in case they're not set.
			$options = array_merge([
				'scheme' => 'ftp',
				'skip' => false,
				'host' => '',
				'user' => '',
				'pass' => '',
				'port' => 21,
				'path' => '/',
				'passive' => true,
				'maintenanceMode' => true,
				'indexPath' => 'web/index.php',
				'maintenancePath' => 'web/.maintenance.php',
				'gitDeployDirectory' => '',
				'clean_directories' => [],
				'after' => [],
				'file_permissions' => [],
				'substitutions' => [],
				'env' => $env,
				'uploadComposerLibs' => false,
			], $options);

			if ($options['scheme'] === 'sftp' && $options['port'] == 21) {
				$options['port'] = 22;
			}

			if ($options['skip']) {
				continue;
			} else {
				$this->servers[$uri] = $options;
			}
		}
	}


	function ignoreFile(string $file): void
	{
		$this->filesToIgnore[] = $file;
	}


	/**
	 * Filter out ignored files & files not placed inside gitDeployDirectory if not empty.
	 * @param array $files
	 * @param string $gitDeployDir
	 * @return array
	 */
	function filterFiles(array $files, string $gitDeployDir): array
	{
		foreach ($files as $key => $file) {
			if (
				in_array($file, $this->filesToIgnore)
				// exclude all but gitDeployDirectory files
				|| (!empty($gitDeployDir) && strpos($file, $gitDeployDir) !== 0)
			) {
				unset($files[$key]);
			}
		}
		return $files;
	}


	function getFilesToUpload(?string $oldRevision = null, string $newRevision = 'HEAD', array $serverOptions = []): array
	{
		$gitDeployDir = (string)($serverOptions['gitDeployDirectory'] ?? '');

		# Get the list of files to update.
		if (!empty($oldRevision)) {
			$command = "git diff --name-status {$oldRevision} {$newRevision}";
		} else {
			$command = "git ls-files";
		}

		$output = [];
		exec($command, $output);

		$filesToUpload = [];
		$filesToDelete = [];

		if (!empty($oldRevision)) {
			foreach ($output as $line) {
				$path = trim(substr($line, 1, strlen($line)));
				if ($line[0] == 'A' or $line[0] == 'C' or $line[0] == 'M') {
					$filesToUpload[] = $path;
				} elseif ($line[0] == 'D') {
					$filesToDelete[] = $path;
					// rename, score 100
				} elseif ($line[0] == 'R') {
					$chunks = explode("\t", $line);
					$filesToDelete[] = $chunks[1];
					$filesToUpload[] = $chunks[2];
				} else {
					throw new Exception("Unknown git-diff status: {$line[0]}");
				}
			}
		} else {
			$filesToUpload = $output;
		}

		$filesToUpload = $this->filterFiles($filesToUpload, $gitDeployDir);
		$filesToDelete = $this->filterFiles($filesToDelete, $gitDeployDir);

		$substitutions = $serverOptions['substitutions'];
		if ($substitutions) {
			$filesToUploadRemotePaths = preg_replace(array_keys($substitutions), array_values($substitutions), $filesToUpload);
			$filesToDeleteRemotePaths = preg_replace(array_keys($substitutions), array_values($substitutions), $filesToDelete);
		} else {
			$filesToUploadRemotePaths = $filesToUpload;
			$filesToDeleteRemotePaths = $filesToDelete;
		}

		return [
			'upload' => array_combine($filesToUpload, $filesToUploadRemotePaths),
			'delete' => array_combine($filesToDelete, $filesToDeleteRemotePaths),
		];
	}


	function output(string $message): void
	{
		if ($this->print) {
			echo $message . "\r\n";
		} else {
			$this->logBuffer .= $message . "\r\n";
		}
	}


	function __destruct() {}


	function revert(): void
	{
		foreach ($this->servers as $server) {
			$this->deployGit($server, 'HEAD', true);
		}
	}


	function deploy(string $revision = 'HEAD'): void
	{
		foreach ($this->servers as $server) {
			$this->deployGit($server, $revision);
		}
	}


	function mkdir($connection, string $file, string $scheme): bool
	{
		$dir = explode('/', str_replace('\\', '/', dirname($file)));
		$path = '';

		for ($i = 0; $i < count($dir); $i++) {
			if ($dir[$i] === '' || $dir[$i] === '.') continue;
			$path .= $dir[$i] . '/';

			if (!isset($this->pathsThatExist[$path])) {
				if ($scheme === 'sftp') {
					if (!$connection->file_exists($path)) {
						if (!$connection->mkdir($path)) {
							// Double check if it was created by another process
							if (!$connection->is_dir($path)) {
								$this->output("Failed to create '$path'.");
								return false;
							}
						} else {
							$this->output("Created directory '$path'.");
						}
					}
					$this->pathsThatExist[$path] = true;
				} else {
					$origin = $this->currentPath;
					if (!@ftp_chdir($connection, $path)) {
						if (!@ftp_mkdir($connection, $path)) {
							// Check if it was created by another process or already exists
							if (!@ftp_chdir($connection, $path)) {
								$this->output("Failed to create '$path'.");
								return false;
							}
						} else {
							$this->output("Created directory '$path'.");
						}
					}
					$this->pathsThatExist[$path] = true;
					@ftp_chdir($connection, $origin);
				}
			}
		}

		return true;
	}


	function deployGit(array $server, string $revision = 'HEAD', bool $revert = false): void
	{

		if ($revision == 'HEAD') {
			$revision = exec('git rev-parse HEAD');
		}

		# Let's make sure the $path ends with a slash.

		if (substr($server['path'], -1) !== '/') {
			$server['path'] = $server['path'] . '/';
		}

		# Okay, let's connect to the server.

		if ($server['scheme'] === 'sftp') {
			$connection = new SFTP($server['host'], $server['port']);
			if (!$connection->login($server['user'], $server['pass'])) {
				throw new Exception("Could not login to {$server['host']} via SFTP (Tried to login as {$server['user']}).");
			}
			if (!$connection->chdir($server['path'])) {
				throw new Exception("Could not change the SFTP directory to {$server['path']}.");
			}
			$this->currentPath = $server['path'];
		} else {
			if ($server['scheme'] === 'ftps') {
				$connection = @ftp_ssl_connect($server['host'], $server['port']);
			} else {
				$connection = @ftp_connect($server['host'], $server['port']);
			}

			if (!$connection) {
				throw new Exception("Could not connect to {$server['host']}.");
			} else {
				if (!ftp_login($connection, $server['user'], $server['pass'])) {
					throw new Exception("Could not login to {$server['host']} (Tried to login as {$server['user']}).");
				}

				ftp_pasv($connection, $server['passive']);
				ftp_set_option($connection, FTP_TIMEOUT_SEC, 300);

				if (ftp_chdir($connection, $server['path'])) {
					$this->currentPath = $server['path'];
				} else {
					throw new Exception("Could not change the FTP directory to {$server['path']}.");
				}
			}
		}

		$this->output(("----------------------------"));
		$this->output("Connected to {$server['host']}{$server['path']} via " . strtoupper($server['scheme']));
		$this->output("----------------------------");

		# Now that we're logged in to the server, let's get the remote revision.

		$remoteRevision = $this->getRemoteRevisionContent($connection, 'REVISION', $server['scheme']);
		$previousRevision = $this->getRemoteRevisionContent($connection, 'PREVIOUS_REVISION', $server['scheme']);
		$isFirstTimeDeploy = $remoteRevision === NULL;
		// clean working directory is required for first-time deploy to avoid massive file renaming while uploading (see below)
		if ($isFirstTimeDeploy) {
			$output = [];
			exec('git status --porcelain', $output);
			if (!empty($output)) {
				$this->output('First-time deployment requires clean working directory! Clean it please and retry!');
				exit;
			}
		}

		if ($revert) {
			if (!isset($previousRevision)) {
				throw new Exception("Could not find previous revision in {$server['host']}, which means that reverting is not possible.");
			}

			$this->output("WARNING: Composer-managed libraries will NOT be reverted!");

			# Set revision to PREVIOUS_REVISION, for reverting.
			$revision = $previousRevision;
			if ($remoteRevision != $revision) {
				$this->output("Reverting from " . substr($remoteRevision, 0, 6) . " to " . substr($revision, 0, 6) . ".");
				$this->output("----------------------------");
			}
		} else {
			if ($remoteRevision && $remoteRevision != $revision) {
				$this->output("Deploying update from " . substr($remoteRevision, 0, 6) . " to " . substr($revision, 0, 6) . ".");
				$this->output("----------------------------");
			}
		}

		$files = $this->getFilesToUpload($remoteRevision, $revision, $server);
		$filesToUpload = $files['upload'];
		$filesToDelete = $files['delete'];
		unset($files);

		$composerLockPath = __DIR__ . '/composer.lock';
		$envComposerLockPath = GIT_DEPLOY_DIR . '/' . $server['env'] . '.composer.lock';

		if ($isFirstTimeDeploy) {

			// paths are relative to root
			$firstTimeDeployFiles = [
				'app/config/user_pass.neon' => 'app/config/user_pass.neon',
			];

			if ($server['uploadComposerLibs']) {
				// upload composer-managed packages
				$dirs = ['vendor/'];
				foreach ($dirs as $relPath) {
					$absPath = __DIR__ . '/' . $relPath;
					if (is_dir($absPath)) {
						foreach (get_recursive_file_list($absPath, $relPath) as $f) {
							// skip git-tracked vendor/others directory
							if (strpos($f, 'vendor/others/') !== 0) {
								$firstTimeDeployFiles[$f] = $f;
							}
						}
					}
				}
			}

			$filesToUpload = array_merge($filesToUpload, $firstTimeDeployFiles);
		} else {
			// check if composer-managed libs have changed
			// we handle only new/updated libraries (to upload), not removed ones (to remove)
			$composerChangedFiles = [];
			$composerLockFileName = $server['gitDeployDirectory'] . 'composer.lock';
			if (isset($filesToUpload[$composerLockFileName])) {
				if (!file_exists($envComposerLockPath)) {
					throw new Exception('Env-specific composer.lock file is missing -> cannot update composer-managed files');
				}
				if (!file_exists($composerLockPath)) {
					throw new Exception('`composer.lock` file is missing -> cannot update composer-managed files');
				}

				// load versioned composer.lock
				$command = "git show $revision:$composerLockFileName";
				$output = [];
				exec($command, $output);
				$localComposerLockJson = json_decode(join('', $output));

				$workingLocalComposerLockJson = json_decode(file_get_contents($composerLockPath));
				if ($workingLocalComposerLockJson->{'content-hash'} !== $localComposerLockJson->{'content-hash'}) {
					$this->output('There are uncommitted changes in `composer.lock` file so it is not safe to deploy now (we could upload packages with other versions than those in composer.lock'
						. "\nPlease commit it and try again.");
					exit;
				}

				$deployedComposerLockJson = json_decode(file_get_contents($envComposerLockPath));
				$localPackages = $localComposerLockJson->packages;
				$deployedPackages = $deployedComposerLockJson->packages;
				if ($localComposerLockJson->{'content-hash'} !== $deployedComposerLockJson->{'content-hash'}) {

					if (!$server['uploadComposerLibs']) {
						if ($server['scheme'] === 'sftp') {
							$this->output('A change in composer managed libraries detected.. Running `composer install` on server via SSH.');
							$command = "cd {$server['path']} && composer install -o --no-dev";
							$sshOutput = $connection->exec($command);
							$this->output("SSH Output:\n" . $sshOutput);
							$this->output('`composer install` command has been executed.');
						} else {
							$this->output('A change in composer managed libraries detected..Please run `composer install` on server.');
						}
					} else {
						/**
						 * Has package version changed?
						 * @param string $name package name
						 * @param string $version current package version
						 * @param string $deployedVersion deployed package version to be set
						 * @return bool
						 */
						$hasPackageChanged = function ($name, $version, &$deployedVersion = NULL) use ($deployedPackages) {
							foreach ($deployedPackages as $p) {
								if ($p->name === $name) {
									$deployedVersion = (string)$p->version;
									if ($p->version === $version) {
										return false;
									}
								}
							}
							return true;
						};

						$composerLibChanged = false;
						foreach ($localComposerLockJson->packages as $p) {
							$deployedVersion = NULL;
							if ($hasPackageChanged($p->name, $p->version, $deployedVersion)) {
								$composerLibChanged = true;
								addFilesFromDirectory('vendor/' . $p->name . '/', $composerChangedFiles);

								$this->output("Composer: <$p->name> changed from <$deployedVersion> to <$p->version>");
							}
						}

						// if changed, copy composer/ & autoload.php
						if ($composerLibChanged) {
							addFilesFromDirectory('vendor/composer/', $composerChangedFiles);
							$composerChangedFiles['vendor/autoload.php'] = 'vendor/autoload.php';
						}

						$filesToUpload = array_merge($filesToUpload, $composerChangedFiles);
					}
				} else {
					$this->output('No change in composer managed libraries detected..');
				}
			}
		}

		$maintenanceModeTurnedOn = false;
		// turn on "Maintenance mode" before uploading
		if (
			$server['maintenanceMode'] && !$isFirstTimeDeploy && (count($filesToUpload) > 0 or count($filesToDelete) > 0)
		) {
			$indexPath = $server['indexPath'];
			$maintenancePath = $server['maintenancePath'];
			$tmpIndexPath = $indexPath . '.tmp';
			if ($server['scheme'] === 'sftp') {
				$connection->rename($indexPath, $tmpIndexPath);
				$connection->rename($maintenancePath, $indexPath);
			} else {
				ftp_rename($connection, $indexPath, $tmpIndexPath);
				ftp_rename($connection, $maintenancePath, $indexPath);
			}
			$this->output('Maintenance mode turned ON');
			$maintenanceModeTurnedOn = true;
		}

		// most of the time $localFile === $remoteFile - $remoteFile just defines path where $localFile gets uploaded
		foreach ($filesToUpload as $localFile => $remoteFile) {
			# Make sure the folder exists in the server.
			$ret = $this->mkdir($connection, $remoteFile, $server['scheme']);
			if ($ret === false) {
				$this->output("A problem occurred while attempting to create a folder. Upload to this server cannot continue.");
				return;
			}

			// first time we upload files as they are (working directory is clean)
			// same for composerChangedFiles as they are not tracked with git
			if ($isFirstTimeDeploy || isset($composerChangedFiles[$localFile])) {
				$unlinkTmpFile = FALSE;
				$tmpFileToUpload = $localFile;
				// other times we upload tmp file with content of $revision
			} else {
				$unlinkTmpFile = TRUE;
				$tmpFileToUpload = GIT_DEPLOY_DIR . '/tmpFileToUpload';
				$command = "git show $revision:$localFile > $tmpFileToUpload";
				$output = [];
				exec($command, $output);
			}

			$uploaded = false;
			$attempts = 1;
			while (!$uploaded) {

				if ($attempts == 10) {
					$this->output("Tried to upload $localFile 10 times, and failed 10 times. Something is wrong, so I'm going to stop executing now.");
					exit;
				}

				# This makes sure to repeat the upload until it finally succeeds.
				if ($server['scheme'] === 'sftp') {
					$uploaded = $connection->put($remoteFile, $tmpFileToUpload, SFTP::SOURCE_LOCAL_FILE);
				} else {
					$ext = strtolower(pathinfo($remoteFile, PATHINFO_EXTENSION));
					$ftpMode = in_array($ext, ['js', 'css', 'html', 'latte', 'php']) ? FTP_ASCII : FTP_BINARY;
					$uploaded = @ftp_put($connection, $remoteFile, $tmpFileToUpload, $ftpMode);
				}

				if (!$uploaded) {
					$attempts = $attempts + 1;
					$this->output("Failed to upload {$localFile}. Retrying (attempt $attempts/10)... ");
					// Small delay before retry
					usleep(500000);
				}
			}
			$this->output("Uploaded {$localFile}");
			if ($unlinkTmpFile) {
				unlink($tmpFileToUpload);
			}
		}

		foreach ($filesToDelete as $file) {
			if ($server['scheme'] === 'sftp') {
				$connection->delete($file);
			} else {
				@ftp_delete($connection, $file);
			}
			$this->output("Deleted {$file}");
		}

		if (!empty($server['clean_directories'])) {
			foreach ($server['clean_directories'] as $dir) {
				$this->rmdirr($connection, $dir, $server['scheme']);
				$this->output("Emptied {$dir}");
			}
		} else {
			$this->output("\r\n*** Don't forget to empty cache if needed! ***\r\n");
		}

		if (count($filesToUpload) > 0 or count($filesToDelete) > 0) {
			$this->output("----------------------------");
			$temp = tempnam(sys_get_temp_dir(), 'gitRevision');
			file_put_contents($temp, $revision);
			if ($server['scheme'] === 'sftp') {
				$connection->put('REVISION', $temp, SFTP::SOURCE_LOCAL_FILE);
			} else {
				ftp_put($connection, 'REVISION', $temp, FTP_ASCII);
			}
			unlink($temp);
			$this->output("Uploaded REVISION file.");

			file_put_contents(getRemoteRevisionLocalFilepath(), $revision);
			$this->output("Stored local REMOTE_REVISION file.");

			# Upload file containing the current revision, for reverting when necessary.
			# But, only if the revision we're deploying is different from the one currently deployed.
			if ($remoteRevision != $revision) {
				$temp = tempnam(sys_get_temp_dir(), 'gitRevision');
				file_put_contents($temp, $remoteRevision);
				if ($server['scheme'] === 'sftp') {
					$connection->put('PREVIOUS_REVISION', $temp, SFTP::SOURCE_LOCAL_FILE);
				} else {
					ftp_put($connection, 'PREVIOUS_REVISION', $temp, FTP_ASCII);
				}
				unlink($temp);
				$this->output("Uploaded PREVIOUS_REVISION file.");
			}

			// update env-specific composer.lock file
			if (file_exists($composerLockPath)) {
				copy($composerLockPath, $envComposerLockPath);
			}
		} else {
			$this->output("No files to upload.");
		}

		# when uploading done turn off "Maintenance mode"
		if ($maintenanceModeTurnedOn) {
			if ($server['scheme'] === 'sftp') {
				$connection->rename($indexPath, $maintenancePath);
				$connection->rename($tmpIndexPath, $indexPath);
			} else {
				ftp_rename($connection, $indexPath, $maintenancePath);
				ftp_rename($connection, $tmpIndexPath, $indexPath);
			}
			$this->output("Maintenance mode turned OFF");
		}

		if (!empty($server['file_permissions'])) {
			$this->setFilePermissions($connection, $server['file_permissions'], $server['scheme']);
		}

		if (!empty($server['after'])) {
			foreach ($server['after'] as $url) {
				@fopen($url, 'r');
				$this->output("$url called");
			}
		}

		$this->output("----------------------------");
		$this->output("Finished working on {$server['host']}{$server['path']}");
		$this->output("----------------------------");

		if ($server['scheme'] === 'sftp') {
			$connection->disconnect();
		} else {
			@ftp_close($connection);
		}
	}


	/**
	 * Clean (and optionally remove) whole directory recursively
	 */
	function rmdirr($handle, string $path, string $scheme, bool $rmDir = false, int $level = 1): bool
	{
		if ($scheme === 'sftp') {
			$list = $handle->nlist($path);
			if ($list !== false) {
				foreach ($list as $value) {
					$baseName = basename($value);
					if ($baseName === '.' || $baseName === '..') continue;
					$fullPath = $path . '/' . $baseName;
					if ($handle->is_dir($fullPath)) {
						$this->rmdirr($handle, $fullPath, $scheme, true, $level + 1);
					} else {
						$handle->delete($fullPath);
					}
				}
			}
			if ($rmDir && $level > 1) {
				return $handle->rmdir($path);
			}
		} else {
			if (!@ftp_delete($handle, $path)) {
				$this->output("Cleaning: $path");
				$list = @ftp_nlist($handle, $path);
				if (!empty($list)) {
					foreach ($list as $value) {
						if (in_array(basename($value), ['.', '..'])) continue;
						$this->rmdirr($handle, $path . '/' . basename($value), $scheme, true, $level + 1);
					}
				}
			}
			if ($rmDir && $level > 1) {
				return @ftp_rmdir($handle, $path);
			}
		}

		return true;
	}


	/**
	 * Set 0777 file permissions for $items (create them if not present)
	 */
	function setFilePermissions($connection, array $items = [], string $scheme = 'ftp'): void
	{
		$mode = 0777;
		foreach ($items as $path) {
			if ($scheme === 'sftp') {
				if (!$connection->chmod($mode, $path)) {
					$connection->mkdir($path);
					$connection->chmod($mode, $path);
				}
			} else {
				if (!@ftp_chmod($connection, $mode, $path)) {
					ftp_mkdir($connection, $path);
					ftp_chmod($connection, $mode, $path);
				}
			}
		}
		$this->output('Permissions set.');
	}


	/**
	 * Get content of remote revision file.
	 */
	function getRemoteRevisionContent($connection, string $filename = 'REVISION', string $scheme = 'ftp'): ?string
	{
		if ($scheme === 'sftp') {
			$content = $connection->get($filename);
			return $content !== false ? trim($content) : null;
		} else {
			$tmpFile = tmpfile();
			$ret = NULL;
			if (@ftp_fget($connection, $tmpFile, $filename, FTP_ASCII)) {
				fseek($tmpFile, 0);
				$ret = trim(fread($tmpFile, 1024));
				fclose($tmpFile);
			}
			return $ret;
		}
	}
}
